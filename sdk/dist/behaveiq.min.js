!function(r,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.BEHAVEIQ=e():r.BEHAVEIQ=e()}(this,()=>(()=>{"use strict";var __webpack_modules__={"./src/core/injector.js"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\r\n * @class Injector\r\n * @description Handles the synchronous application of personalization rules to the DOM.\r\n * This is a core part of the zero-flicker personalization strategy.\r\n */\r\nclass Injector {\r\n    constructor() {\r\n        this.appliedRules = new Set();\r\n    }\r\n\r\n    /**\r\n     * Synchronously applies a set of personalization rules to the DOM.\r\n     * This method is designed to be called from a script in the <head>\r\n     * after the anti-flicker snippet and before the body is visible.\r\n     * @param {Array<Object>} rules - An array of personalization rule objects.\r\n     */\r\n    apply(rules = []) {\r\n        try {\r\n            if (!rules || rules.length === 0) {\r\n                return;\r\n            }\r\n\r\n            // The DOM should be queryable at this point, even if not fully loaded.\r\n            this.injectContent(rules);\r\n\r\n        } catch (error) {\r\n            console.error('BEHAVEIQ: Personalization error:', error);\r\n        } finally {\r\n            // ALWAYS unhide the body to prevent the page from staying blank.\r\n            this.unhideBody();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Injects the content based on the rules.\r\n     * @param {Array<Object>} rules - The rules to inject.\r\n     */\r\n    injectContent(rules) {\r\n        for (const rule of rules) {\r\n            if (!rule.selector || this.appliedRules.has(rule.ruleId)) {\r\n                continue;\r\n            }\r\n\r\n            try {\r\n                // Find the element(s). This runs before DOMContentLoaded, so we rely\r\n                // on the elements being present in the initial HTML payload.\r\n                const elements = document.querySelectorAll(rule.selector);\r\n\r\n                if (elements.length === 0) {\r\n                    // It's common for elements to not be found if they are rendered by client-side JS.\r\n                    // This synchronous injector can only act on server-rendered HTML.\r\n                    continue;\r\n                }\r\n\r\n                elements.forEach(element => {\r\n                    // Directly manipulate the content. The page is not visible yet.\r\n                    switch (rule.contentType) {\r\n                        case 'text':\r\n                            element.textContent = rule.content;\r\n                            break;\r\n                        case 'html':\r\n                            element.innerHTML = rule.content;\r\n                            break;\r\n                        case 'image':\r\n                            if (element.tagName === 'IMG') {\r\n                                element.src = rule.content;\r\n                            }\r\n                            break;\r\n                        default:\r\n                            element.textContent = rule.content;\r\n                    }\r\n                });\r\n\r\n                this.appliedRules.add(rule.ruleId);\r\n\r\n            } catch (error) {\r\n                // Log error for the specific rule but continue processing others.\r\n                console.error(`BEHAVEIQ: Error applying rule ${rule.ruleId}:`, error);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Makes the body of the page visible.\r\n     * This should be called after all synchronous DOM manipulations are complete.\r\n     */\r\n    unhideBody() {\r\n        // This targets the style applied by the anti-flicker snippet.\r\n        if (document.body) {\r\n            document.body.style.opacity = '1';\r\n        } else {\r\n            // If the body isn't even parsed yet, we can wait for it.\r\n            document.addEventListener('DOMContentLoaded', () => {\r\n                if(document.body) document.body.style.opacity = '1';\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Injector);\n\n//# sourceURL=webpack://BEHAVEIQ/./src/core/injector.js?\n}")},"./src/core/tracker.js"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_network__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/network */ \"./src/utils/network.js\");\n/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/helpers */ \"./src/utils/helpers.js\");\n\r\n\r\n\r\nclass Tracker {\r\n    constructor(options) {\r\n        this.apiKey = options.apiKey;\r\n        this.sessionId = options.sessionId;\r\n        this.fingerprint = options.fingerprint;\r\n        this.apiUrl = options.apiUrl;\r\n        this.config = options.config;\r\n\r\n        this.eventQueue = [];\r\n        this.flushInterval = 5000; // 5 seconds\r\n        this.startTime = Date.now();\r\n        this.pageStartTime = Date.now();\r\n\r\n        // Start flush interval\r\n        setInterval(() => this.flush(), this.flushInterval);\r\n    }\r\n\r\n    /**\r\n     * Track page view\r\n     */\r\n    trackPageView() {\r\n        this.sendEvent('pageview', {\r\n            pageUrl: window.location.href,\r\n            pageTitle: document.title,\r\n            referrer: document.referrer\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Track mouse movement (throttled)\r\n     */\r\n    trackMouse() {\r\n        const handleMouseMove = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_1__.throttle)((e) => {\r\n            this.queueEvent('mousemove', {\r\n                x: e.clientX,\r\n                y: e.clientY,\r\n                pageUrl: window.location.href\r\n            });\r\n        }, 2000); // Send every 2 seconds max\r\n\r\n        document.addEventListener('mousemove', handleMouseMove);\r\n    }\r\n\r\n    /**\r\n     * Track scroll depth\r\n     */\r\n    trackScroll() {\r\n        let maxScrollDepth = 0;\r\n\r\n        const handleScroll = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_1__.throttle)(() => {\r\n            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;\r\n            const docHeight = document.documentElement.scrollHeight - window.innerHeight;\r\n            const scrollDepth = docHeight > 0 ? scrollTop / docHeight : 0;\r\n\r\n            if (scrollDepth > maxScrollDepth) {\r\n                maxScrollDepth = scrollDepth;\r\n\r\n                this.queueEvent('scroll', {\r\n                    scrollDepth: parseFloat(scrollDepth.toFixed(2)),\r\n                    scrollDirection: 'down',\r\n                    pageUrl: window.location.href\r\n                });\r\n            }\r\n        }, 1000);\r\n\r\n        window.addEventListener('scroll', handleScroll);\r\n    }\r\n\r\n    /**\r\n     * Track clicks\r\n     */\r\n    trackClicks() {\r\n        document.addEventListener('click', (e) => {\r\n            const element = e.target;\r\n\r\n            this.sendEvent('click', {\r\n                element: element.tagName.toLowerCase(),\r\n                elementText: element.textContent?.substring(0, 100) || '',\r\n                elementId: element.id || '',\r\n                elementClass: element.className || '',\r\n                x: e.clientX,\r\n                y: e.clientY,\r\n                pageUrl: window.location.href\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Track page exit\r\n     */\r\n    trackExit() {\r\n        const sendExitEvent = () => {\r\n            const timeSpent = Math.floor((Date.now() - this.pageStartTime) / 1000);\r\n\r\n            // Use sendBeacon for reliable sending on page unload\r\n            const data = JSON.stringify({\r\n                apiKey: this.apiKey,\r\n                sessionId: this.sessionId,\r\n                eventType: 'exit',\r\n                eventData: {\r\n                    pageUrl: window.location.href,\r\n                    timeSpent\r\n                },\r\n                userAgent: navigator.userAgent,\r\n                fingerprint: this.fingerprint\r\n            });\r\n\r\n            navigator.sendBeacon(\r\n                `${this.apiUrl}/sdk/track`,\r\n                new Blob([data], { type: 'application/json' })\r\n            );\r\n        };\r\n\r\n        window.addEventListener('beforeunload', sendExitEvent);\r\n        window.addEventListener('pagehide', sendExitEvent);\r\n    }\r\n\r\n    /**\r\n     * Track custom event\r\n     */\r\n    trackCustomEvent(eventName, metadata) {\r\n        this.sendEvent('custom', {\r\n            eventName,\r\n            customData: metadata,\r\n            pageUrl: window.location.href\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Queue event for batch sending\r\n     */\r\n    queueEvent(eventType, eventData) {\r\n        this.eventQueue.push({\r\n            eventType,\r\n            eventData,\r\n            timestamp: Date.now()\r\n        });\r\n\r\n        // Flush if queue is large\r\n        if (this.eventQueue.length >= 10) {\r\n            this.flush();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send event immediately\r\n     */\r\n    async sendEvent(eventType, eventData) {\r\n        try {\r\n            await _utils_network__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(`${this.apiUrl}/sdk/track`, {\r\n                apiKey: this.apiKey,\r\n                sessionId: this.sessionId,\r\n                eventType,\r\n                eventData,\r\n                userAgent: navigator.userAgent,\r\n                fingerprint: this.fingerprint\r\n            });\r\n\r\n            if (this.config.debug) {\r\n                console.log('BEHAVEIQ: Event sent:', eventType, eventData);\r\n            }\r\n        } catch (error) {\r\n            console.error('BEHAVEIQ: Error sending event:', error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Flush event queue\r\n     */\r\n    async flush() {\r\n        if (this.eventQueue.length === 0) return;\r\n\r\n        const events = [...this.eventQueue];\r\n        this.eventQueue = [];\r\n\r\n        // Send all queued events\r\n        for (const event of events) {\r\n            await this.sendEvent(event.eventType, event.eventData);\r\n        }\r\n    }\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tracker);\n\n//# sourceURL=webpack://BEHAVEIQ/./src/core/tracker.js?\n}")},"./src/index.js"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _core_tracker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/tracker */ "./src/core/tracker.js");\n/* harmony import */ var _core_injector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core/injector */ "./src/core/injector.js");\n/* harmony import */ var _utils_storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/storage */ "./src/utils/storage.js");\n/* harmony import */ var _utils_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/helpers */ "./src/utils/helpers.js");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @class BEHAVEIQ\r\n * @description The main class for the BehaveIQ SDK.\r\n * It handles both synchronous personalization and asynchronous event tracking.\r\n */\r\nclass BEHAVEIQ {\r\n    constructor() {\r\n        this.isInitialized = false;\r\n        this.apiUrl = \'https://api.behaveiq.com/api/v1\'; // Default API URL\r\n    }\r\n\r\n    /**\r\n     * Initializes the SDK.\r\n     * This is the main entry point. For zero-flicker personalization, this method\r\n     * must be called from a synchronous script in the <head> of the page.\r\n     * @param {string} apiKey - Your project\'s API key.\r\n     * @param {Object} [options={}] - Configuration options.\r\n     * @param {Array<Object>} [options.personalizationRules=[]] - Personalization rules to apply synchronously.\r\n     * @param {Object} [options.config={}] - Other configuration like tracking settings.\r\n     */\r\n    init(apiKey, options = {}) {\r\n        if (this.isInitialized) {\r\n            console.warn(\'BEHAVEIQ: Already initialized\');\r\n            return;\r\n        }\r\n\r\n        const { personalizationRules = [], config = {} } = options;\r\n\r\n        // --- 1. Synchronous Personalization (Zero-Flicker) ---\r\n        // This part runs immediately to prevent content flicker.\r\n        try {\r\n            const injector = new _core_injector__WEBPACK_IMPORTED_MODULE_1__["default"]();\r\n            injector.apply(personalizationRules); // This method also unhides the body.\r\n        } catch (e) {\r\n            console.error(\'BEHAVEIQ: Critical error during personalization. Unhiding page.\', e);\r\n            // Ensure the page is always visible even if personalization fails.\r\n            new _core_injector__WEBPACK_IMPORTED_MODULE_1__["default"]().unhideBody();\r\n        }\r\n\r\n        // --- 2. Asynchronous Tracking Initialization ---\r\n        // This part can run without blocking the page render.\r\n        // We wrap it in a function to be called after the current script stack clears.\r\n        setTimeout(() => {\r\n            this.apiKey = apiKey;\r\n            this.config = {\r\n                trackMouse: config.trackMouse !== false,\r\n                trackScroll: config.trackScroll !== false,\r\n                trackClicks: config.trackClicks !== false,\r\n                debug: config.debug || false,\r\n                apiUrl: config.apiUrl || this.apiUrl\r\n            };\r\n\r\n            // Generate fingerprint and session ID\r\n            this.fingerprint = (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_3__.generateFingerprint)();\r\n            this.sessionId = _utils_storage__WEBPACK_IMPORTED_MODULE_2__["default"].get(\'behaveiq_session\') || (0,_utils_helpers__WEBPACK_IMPORTED_MODULE_3__.generateSessionId)();\r\n            _utils_storage__WEBPACK_IMPORTED_MODULE_2__["default"].set(\'behaveiq_session\', this.sessionId, 30); // 30 minutes\r\n\r\n            // Initialize tracker\r\n            this.tracker = new _core_tracker__WEBPACK_IMPORTED_MODULE_0__["default"]({\r\n                apiKey: this.apiKey,\r\n                sessionId: this.sessionId,\r\n                fingerprint: this.fingerprint,\r\n                apiUrl: this.config.apiUrl,\r\n                config: this.config\r\n            });\r\n            \r\n            // Start tracking basic events\r\n            this.tracker.trackPageView();\r\n            this.tracker.trackExit();\r\n\r\n            if (this.config.trackScroll) this.tracker.trackScroll();\r\n            if (this.config.trackClicks) this.tracker.trackClicks();\r\n            if (this.config.trackMouse) this.tracker.trackMouse();\r\n\r\n            this.isInitialized = true;\r\n\r\n            if (this.config.debug) {\r\n                console.log(\'BEHAVEIQ tracking initialized:\', {\r\n                    apiKey: this.apiKey,\r\n                    sessionId: this.sessionId\r\n                });\r\n            }\r\n        }, 0);\r\n    }\r\n\r\n    /**\r\n     * Tracks a custom event.\r\n     * @param {string} eventName - The name of the event.\r\n     * @param {Object} [metadata={}] - Custom data associated with the event.\r\n     */\r\n    track(eventName, metadata = {}) {\r\n        // Queue the event if the SDK is not yet initialized.\r\n        if (!this.isInitialized || !this.tracker) {\r\n            (this._q = this._q || []).push([\'track\', eventName, metadata]);\r\n            return;\r\n        }\r\n        this.tracker.trackCustomEvent(eventName, metadata);\r\n    }\r\n    \r\n    /**\r\n     * Gets the current session ID.\r\n     */\r\n    getSessionId() {\r\n        return this.sessionId;\r\n    }\r\n}\r\n\r\n// --- Global Setup ---\r\n// Create a global instance and a command queue.\r\n// This ensures that any `BEHAVEIQ.track()` calls made before `init()` is complete\r\n// are captured and executed later.\r\nconst instance = new BEHAVEIQ();\r\nif (typeof window !== \'undefined\') {\r\n    const queue = window.BEHAVEIQ && window.BEHAVEIQ._q ? window.BEHAVEIQ._q : [];\r\n    window.BEHAVEIQ = instance;\r\n    window.BEHAVEIQ._q = queue; // Restore queue\r\n\r\n    // Process any queued commands\r\n    setTimeout(() => {\r\n        if (instance.isInitialized) {\r\n            while (window.BEHAVEIQ._q.length > 0) {\r\n                const [method, ...args] = window.BEHAVEIQ._q.shift();\r\n                if (typeof instance[method] === \'function\') {\r\n                    instance[method](...args);\r\n                }\r\n            }\r\n        }\r\n    }, 100);\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (instance);\n\n//# sourceURL=webpack://BEHAVEIQ/./src/index.js?\n}')},"./src/utils/helpers.js"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   debounce: () => (/* binding */ debounce),\n/* harmony export */   generateFingerprint: () => (/* binding */ generateFingerprint),\n/* harmony export */   generateSessionId: () => (/* binding */ generateSessionId),\n/* harmony export */   throttle: () => (/* binding */ throttle)\n/* harmony export */ });\n/**\r\n * Generate unique fingerprint\r\n */\r\nfunction generateFingerprint() {\r\n    const canvas = document.createElement('canvas');\r\n    const ctx = canvas.getContext('2d');\r\n    ctx.textBaseline = 'top';\r\n    ctx.font = '14px Arial';\r\n    ctx.fillText('BEHAVEIQ', 2, 2);\r\n\r\n    const canvasData = canvas.toDataURL();\r\n\r\n    const fingerprint = {\r\n        userAgent: navigator.userAgent,\r\n        language: navigator.language,\r\n        platform: navigator.platform,\r\n        screenResolution: `${window.screen.width}x${window.screen.height}`,\r\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\r\n        canvas: hashCode(canvasData)\r\n    };\r\n\r\n    return hashCode(JSON.stringify(fingerprint));\r\n}\r\n\r\n/**\r\n * Generate random session ID\r\n */\r\nfunction generateSessionId() {\r\n    return 'sess_' + Date.now() + '_' + Math.random().toString(36).substring(7);\r\n}\r\n\r\n/**\r\n * Simple hash function\r\n */\r\nfunction hashCode(str) {\r\n    let hash = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n        const char = str.charCodeAt(i);\r\n        hash = ((hash << 5) - hash) + char;\r\n        hash = hash & hash;\r\n    }\r\n    return Math.abs(hash).toString(36);\r\n}\r\n\r\n/**\r\n * Throttle function\r\n */\r\nfunction throttle(func, delay) {\r\n    let lastCall = 0;\r\n    return function (...args) {\r\n        const now = Date.now();\r\n        if (now - lastCall >= delay) {\r\n            lastCall = now;\r\n            return func(...args);\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Debounce function\r\n */\r\nfunction debounce(func, delay) {\r\n    let timeoutId;\r\n    return function (...args) {\r\n        clearTimeout(timeoutId);\r\n        timeoutId = setTimeout(() => func(...args), delay);\r\n    };\r\n}\n\n//# sourceURL=webpack://BEHAVEIQ/./src/utils/helpers.js?\n}")},"./src/utils/network.js"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Network {\r\n    /**\r\n     * Make GET request\r\n     */\r\n    static async get(url) {\r\n        try {\r\n            const response = await fetch(url, {\r\n                method: 'GET',\r\n                headers: {\r\n                    'Content-Type': 'application/json'\r\n                }\r\n            });\r\n\r\n            if (!response.ok) {\r\n                throw new Error(`HTTP error! status: ${response.status}`);\r\n            }\r\n\r\n            return await response.json();\r\n        } catch (error) {\r\n            console.error('Network GET error:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Make POST request\r\n     */\r\n    static async post(url, data) {\r\n        try {\r\n            const response = await fetch(url, {\r\n                method: 'POST',\r\n                headers: {\r\n                    'Content-Type': 'application/json'\r\n                },\r\n                body: JSON.stringify(data)\r\n            });\r\n\r\n            if (!response.ok) {\r\n                throw new Error(`HTTP error! status: ${response.status}`);\r\n            }\r\n\r\n            return await response.json();\r\n        } catch (error) {\r\n            console.error('Network POST error:', error);\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Network);\n\n//# sourceURL=webpack://BEHAVEIQ/./src/utils/network.js?\n}")},"./src/utils/storage.js"(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Storage {\r\n    /**\r\n     * Get item from localStorage\r\n     */\r\n    static get(key) {\r\n        try {\r\n            const item = localStorage.getItem(`behaveiq_${key}`);\r\n            if (!item) return null;\r\n\r\n            const parsed = JSON.parse(item);\r\n\r\n            // Check expiration\r\n            if (parsed.expiry && Date.now() > parsed.expiry) {\r\n                localStorage.removeItem(`behaveiq_${key}`);\r\n                return null;\r\n            }\r\n\r\n            return parsed.value;\r\n        } catch (error) {\r\n            console.error('Storage get error:', error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set item in localStorage with expiration (in minutes)\r\n     */\r\n    static set(key, value, expiryMinutes = null) {\r\n        try {\r\n            const item = {\r\n                value,\r\n                expiry: expiryMinutes ? Date.now() + (expiryMinutes * 60 * 1000) : null\r\n            };\r\n\r\n            localStorage.setItem(`behaveiq_${key}`, JSON.stringify(item));\r\n        } catch (error) {\r\n            console.error('Storage set error:', error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove item from localStorage\r\n     */\r\n    static remove(key) {\r\n        try {\r\n            localStorage.removeItem(`behaveiq_${key}`);\r\n        } catch (error) {\r\n            console.error('Storage remove error:', error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear all BEHAVEIQ data\r\n     */\r\n    static clear() {\r\n        try {\r\n            const keys = Object.keys(localStorage);\r\n            keys.forEach(key => {\r\n                if (key.startsWith('behaveiq_')) {\r\n                    localStorage.removeItem(key);\r\n                }\r\n            });\r\n        } catch (error) {\r\n            console.error('Storage clear error:', error);\r\n        }\r\n    }\r\n}\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Storage);\n\n//# sourceURL=webpack://BEHAVEIQ/./src/utils/storage.js?\n}")}},__webpack_module_cache__={};function __webpack_require__(r){var e=__webpack_module_cache__[r];if(void 0!==e)return e.exports;if(void 0===__webpack_modules__[r]){var n=new Error("Cannot find module '"+r+"'");throw n.code="MODULE_NOT_FOUND",n}var t=__webpack_module_cache__[r]={exports:{}};return __webpack_modules__[r](t,t.exports,__webpack_require__),t.exports}__webpack_require__.d=(r,e)=>{for(var n in e)__webpack_require__.o(e,n)&&!__webpack_require__.o(r,n)&&Object.defineProperty(r,n,{enumerable:!0,get:e[n]})},__webpack_require__.o=(r,e)=>Object.prototype.hasOwnProperty.call(r,e),__webpack_require__.r=r=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(r,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(r,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/index.js");return __webpack_exports__})());